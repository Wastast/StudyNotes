## 对象
#### 语法:可以使用字面量方式创建，也可以使用new方法创建
>* new方法创建: `var Myobjet = new Object()`，该方法创建会使用new创建出一个新的对象空间，然后返回一个新的对象空间引用。
>* 字面量创建:`var Myobject = {name:name}`不会创建出多余的空间，添加属性需要手动逐个添加
>* 总结: 创建单个对象时，最好使用字面量创建方式，不会造成空间浪费。如果需要更多选项时，使用new(构造函数)方式创建

#### 类型:
>* 基本类型:一共有6中基本类型:string,number,bool,object,null,undefined.`typeof null`时，会返回Object，原因是：JavaScript在底层都使用二进制保存数据，前三位为0的数据被默认为Object类型，null保存为都是0，所以为Object
>* 关于构造函数: 构造函数都是使用统一的语句` var obj = new Fn()`，实际上这些Fn()函数都是普通的函数(无论是否是内置函数),但使用时增加了前缀new 这些函数都会变成构造函数.
>* new在运行时会执行4个步骤:
>>1. 创建一个对象空间
>>2. 自动设置继承关系，继承函数的原型对象
>>3. 调用new 后面的函数，并将函数里的所有this,自动绑定new对象,通过这种方式吗，给new里的对象空间添加新的属性
>>4. 将new对象空间，返回给变量，变量保存着new对象空间的引用地址，
#### 属性内容
>* obj.a 这种访问方式称为属性访问.
>* obj[".."] 这种访问方式称为键访问。引入键值对的概念
>* 属性访问方式比键访问要简便许多,但也存在缺陷.
>>1. 属性访问要求属性值必须符合变量声明规范，`obj.super-fun!` 这样的属性名称使用，属性访问方式会出错，使用键访问不会。
>>2. 在覆盖值的时候使用属性访问方式就会出错，`var obj.key =obj.key`,属性访问方式不能访问变量形式，键访问就可以
>* 在JS中保存属性的方式是以字符串形式保存的，数组的下标也是使用字符串形式保存的,使用`var arr['50'] = 50`，保存为数组时，会在数组50下标的位置保存一个50的值，所以使用关联数组时，不要使用数字的关联方式。(数组最好只保存下标的值，不要保存属性和值，使用对象来保存属性和值)
#### 属性描述符
>* writable:描述属性是否只读，`writable:false`为只读，只能获取数据，不能修改数据，如果修改数据会静默失败，而且在严格模式中会报错
>* enumerable:描述属性是否可遍历(for循环)，`enumerable:false`,表示该属性不可枚举，但该设置只能是单纯的不能被枚举，使用obj.a属性访问时还是能被访问
>* configurable:该描述属性有两个方面的设置.`configurable:false` 第一点表示为，该属性不可删除，不能使用delete 删除。 第二点表示为：该属性里的属性描述符不可被更改。将属性描述符设置后，添加上`configurable:false`，在以后的程序里就无法修改该属性里的描述符，修改就会报错
>* 保护对象的三个层次
>>1. 禁止扩展(不能追加属性)
`Object.preventExtensions(obj)`该对象不能进行添加属性，添加后会静默失败，在严格模式下会爆出错误警告
>>2. 密封(不能添加也不能删除)`Object.seal()`在禁止扩展的基础上添加了`configurable:false`，使属性的描述符不能被更改也不能删除属性
>>3. 冻结(不能添加，不能删除，不能更改)`Object.freeze`在前两者的基础上又添加了`writable:false`，使属性的值也不能被更改
#### 访问器属性
> * Get: 每个属性在被使用时，都会进行一次Get操作，获取属性值，该操作会查找对象里是否具有该属性，如果没有就查找对象的原型链，一直查找到顶端Object.prototype，找不到就返回undefined,找到就返回该属性的值.如果引用了一个当前词法作用域不存在的属性，并不会返回undefined，而是直接返回抛出一个类型异常
>* Put:每个属性在被赋值的时候会进行一次Put操作。该操作有三个步骤
>>1. 该属性是否是访问描述符?如果是，且存在set调用，就调用set
>>2. 该属性的属性描述符中`writable:false`只读属性是否是false，如果是false,则静默失败，严格模式出会抛出错误。
>>3. 如果都不是，将该值进行赋值。调用了set函数后，set函数内会自行赋值

#### 存在判断
> * in操作符: `(a in obj)`. in操作符不仅会检查属性是否存在obj的对象里，还会检查属性a 是否存在Obj对象的原型链中.还有in操作符实际检查的是某个属性名是否存在,如果检查数组下标则会出错`4 in [2,4,6]` 该数组只有0,1,2 并没有4 所以下标不存在会报错
> * 函数自身具有的:hasOwnProperty:`myObject.hasOwnProperty('a')`：该操作符只会检查属性是否存在对象中，不会深入检查原型链 