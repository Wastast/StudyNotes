### 1.编译的基本原理:
 >* 编译会进行三个步骤: 词法分析-->语法分析--代码生成
            
 >* 词法分析: 该阶段主要是将代码(字符串)拆分成有意义的代码块(字符),这些代码块被称为词法单元

 >* 语法分析: 将词法分析的词法单元流转换成一个由元素嵌套组合成的程序结构树(AST:抽象语法树)

 >* 代码生成: 该阶段是将AST(抽象语法树)转换成机器指令
----------------
### 2.什么是LHS和RHS
> LHS：赋值的左侧查询 如果查找的目的是对变量进行赋值(找到值)就会进行LHS查询，LHS类型引用错误会抛出TypeError
         
>RHS：赋值的右侧查询 如果查找的目的是找到变量的值，就会进行RHS查询 (return a+b); 找到a和b变量的值，在进行相加不成功的RHS查询，会导致抛出ReferenceError异常
---------------
### 3.作用域
>1. 作用域的概念：限定一段代码或者一些变量的活动范围就是作用域。

>2. 词法作用域：词法作用域就是定义在词法分析阶段的作用域，根据程序员在写代码时将变量和块级作用域 放在何处决定的，大多数时候是不会发生变化的无论函数在哪里被调用，如何被调用，函数作用域也不会改变，根据函数被声明时所处的位置决定
>欺骗词法作用域：eval()和with().这两个函数可以达到欺骗词法作用域的效果，eval()可以改变词法作用域的范围，with()会创造一个全新的词法作用域，with()还有一个致命的缺点，当with()找不到相同的变量时，会在全局作用域范围上，创建一个全局变量，污染全局环境

>3. 函数作用域：函数作用域等同于一个小型的全局作用域，在函数作用域可以嵌套其他作用域，如果是定义在全局作用域下的函数，等同于给window对象添加方法可以使用**window.方法名**方式调用函数

>4. 块级作用域：在ES5之前javascript都没有块级作用域的说法，在ES6添加了**let**变量声明的方式，可以在if 或者 for 语句块中形成块级作用域 
------------------
### 4.关于JavaScript的性能问题
>JavaScript 引擎会在编译阶段进行数项的性能优化，有些优化能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置方便能够在程序执行过程中，快速的找到标识符。而eval()和with()的使用会破坏词法作用域的生成，因为eval()和with()都会动态的产生词法作用域，这样javascript引擎在解析的时候就因为不清楚这两个函数里具有什么样的作用域，而进行简单而模糊的解析。造成后面使用的时候需要重新解析一次作用域，从而造成性能上的浪费
------------------
### 5.遮蔽效应
>当子函数和父函数都定义相同的变量名时，在子函数里调用该变量，子函数的该变量数据会替换掉父函数的变量。这是因为，引擎的RHS查询在当前作用域找到相同的变量后就不会再往下寻找，而是直接将找到的变量值赋予引用RHS查询的变量。这就是遮蔽效应，子函数会遮蔽父函数，前提是使用相同的变量名
------------
### 6.最小暴露原则
>函数区域内应最小限度的暴露出函数的必要内容，最好只暴露出接口，方便其他函数引用即可
---------
### 7.声明提升
>* JavaScript 有两种声明提升的方式，一种是变量声明提升，一种的函数声明提升，两种虽然都会提升声明但区别不一样

>* 变量提升：在编译器编译的过程中，都会把所有的**var** 进行提升声明，使引擎认识，但声明不代表使用，变量的声明提升只是使引擎先行认识该变量，但对该变量的引用和赋值都会停留在最初的地方，不会被提升
`console.log(a); // 显示undefined`
`var a = 10;     // 为a进行赋值`
`console.log(a); // 输出为10`
第一个console.log(a)为undefined 是因为引擎知道了有a的存在，但是并未进行使用(引用，赋值)，所以进行输出时，a为未定义
执行var a = 10; 的时候才正式对a 这个变量进行赋值
后面的console.log(a)就正常输出为10了。这时候可以了解到，引擎对var a = 10; 这段语句进行了两次执行，第一次执行是编译器对a进行变量声明提升，第二次执行是到赋值语句的代码行对a进行赋值

>* 函数声明提升: 函数声明提升于变量声明提升存在很大的区别。先看下面代码
`fun(); //输出为2`
`function fun(){console.log(1)} //fun1`
`fun(); //输出为2`
`function fun(){console.log(2)} //fun2`
该代码块的两个函数都被声明提升了，fun1最先被声明提升，因为js是单线程顺序执行的语言，fun2后被声明提升，js函数有个特点，不允许存在同样的函数名，所以fun1无情的被fun2替代，甚至淹没覆盖了，函数声明提升还有一个特点，整个代码块都会被同时提升，这就造成了，fun2完全替代了fun1，导致两次fun调用都输出为2,因为fun1被隐式淹没了
-------